《spring cloud微服务实战》
API->Feign->Hytrix->Ribbon
 1.基础知识
    实施微服务：运维的新挑战、接口的一致性、分布式的复杂性
    去中心化治理
    springCloud是一个基于springBoot实现的微服务架构开发工具
 2.微服务构建spring boot
    2.1框架简介
    2.2快速入门
    2.3配置详解
        yaml比起properties的优势在于其是有序的
    2.4监控与管理
        actuar
 3.服务治理Eureka
    eureka提供了region和zone两个概念来进行分区，这两个概念均来自于亚马逊的AWS：
        region：可以简单理解为地理上的分区，比如亚洲地区，或者华北地区，再或者北京等等，没有具体大小的限制。根据项目具体的情况，可以自行合理划分region。
        zone：可以简单理解为region内的具体机房，比如说region划分为北京，然后北京有两个机房，就可以在此region之下划分出zone1,zone2两个zone。
    3.1服务治理
        服务治理是微服务架构中最为核心的模块，它主要用来实现各个微服务实例的自动化注册与发现
        服务注册:每个服务单元向注册中心登记自己提供的服务。若不可用需要从服务清单中剔除。
        服务发现:服务间的调用不在通过指定具体的实例地址，而是通过向服务名发起请求调用
        Eureka它即包含了服务端组件也包含了客户端组件。服务端称为注册中心。客户端主要处理注册与发现。
        服务发现与消费:服务消费的任务由Ribbon完成。Ribbon是一个基于HTTP和TCP的客户端负载均衡器。通过@LoadBlanced注解开启客户端负载均衡
    3.2Eureka详解
        基础架构
            服务注册中心:Eureka提供的服务端
            服务提供者:提供服务的应用，通常是springboot应用。将自己注册到Eureka供其他应用平台发现
            服务消费:消费者应用从服务注册中心获取服务列表，从而使消费者可以知道去何处调用其所需要的服务
        服务治理机制(示例)
            “服务注册中心-1”和“服务注册中心-2”，它们互相注册组成了高可用集群(并且互相复制)
            “服务提供者者“启动了两个实例，一个注册到”服务注册中心-1“，另一个注册到”服务注册中心-2“
            还有两个”服务消费者“，它们也都分别指向了一个注册中心
        服务提供者
            服务注册:启动的时候通过发送REST请求的方式将自己注册到Eureka Server上。Eureka Server接收到这个REST请求后将元数据信息储存到双层Map中，第一层是key的服务名，第二层是key的具体实例名
            服务同步:由于服务注册中心之间互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将请求转发给集群中相连的其它注册中心，从而实现注册中心之间的服务同步。服务提供者的服务信息可以通过这两台服务注册中心的任意一台获取到，
            服务续约:心跳及失效。默认心跳30s，失效90s
        服务消费者
            获取服务:启动服务消费者的时候，会发送一个REST请求给注册中心，默认缓存30s
            服务调用:客户端在Ribbon使用轮询进行调用
            服务下线:当服务实例进行正常的关闭操作时发送REST给注册中心，并进行传播
        服务注册中心
            失效剔除:Eureka Server会启用一个定时任务默认90s
            自我保护:将心跳比例成功率过低的(默认15分钟85%)进行下线
        源码分析
            将一个普通给的springBoot应用注册到Eureka或是从Eureka获取列表主要做了两件事:1.配置@EnableDiscoveryClient，2.配置文件指定服务注册中心位置DiscoveryClient是spring cloud的接口，定义了用来发现服务的常用抽象方法(切换治理框架不需要改代码)。真正实现发现服务的com.netflix.discovery.DiscoveryClient类。
            region、Zone
                户端依次加载Region、Zone。在获取了Region、Zone的信息之后，才开始加载真正的EurekaServer的具体地址。
            serviceUrls
                它根据传入的参数按一定算法确定加载哪一个Zone配置的serviceUrls。当我们使用 Ribbon进行服务调用时会优先使用同一个Zone的
            服务注册
                注册操作是通过REST请求的方式进行的。同时传入com.netflix.appinfo.InstanceInfo对象，该对象是注册时客户端给服务端的服务的元数据
            服务获取与服务续约
                DiscoveryClient的initScheduledTasks函数有两个定时任务分别是服务获取与服务续约。其中续约就是REST请求，而服务获取会区分是否为第一次发起
            服务注册中心处理
                在对注册信息进行了一堆校验之后，会调用org.springframwork.cloud.netflix.eureka.server.InstanceRegistry对象中的register函数。先将新服务注册的事件传播出去，然后将元数据存储在双层concurrentHashMap中
    3.3配置详解
        客户端的配置主要分为以下两个方面
            服务注册相关的配置信息，包括服务注册中心的地址、服务获取的间隔时间、可用区域等。
            服务实例相关的配置信息，包括实例的名称、IP地址、端口号、健康检查路径等。
        服务注册类配置
            指定注册中心:集群则用逗号分隔
            其它配置
        服务实例类配置
            元数据:服务名称、实例名称、ip、实例端口等
        健康检测
            默认情况下不通过actuator的health实现
    3.4跨平台支持
        支持其他语言
 4.负载均衡Ribbon
    4.1客户端负载均衡
        客户端与服务端负载均衡最大的不同点在于服务清单所存储的位置
        在微服务架构中使用客户端负载均衡非常简单只需如下两步
            服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心。
            服务消费者直接通过调用被@LoadBanlanced注解修饰过的RestTemplate来实现面向服务的接口调用
    4.2RestTemplate请求
        get、post、delete都有三个重载方法
    4.3源码分析
        LoadBalanceClient是spring cloud的一个接口。LoadBalancerAutoConfiguration为客户端负载均衡器的自动化配置
        Ribbon实现的负载均衡自动化配置需要满足下面两个条件
            RestTmplate类必须存在于当前环境中
            Spring的Bean工程必须有LoadBanlanceClient的实现bean
        该自动化配置类中，主要做了下面三件事
            创建LoadBanlancerInterceptor的Bean，用于实现对客户端发起请求时进行拦截
            创建RestTemplateCustomizer的bean，用于给RestTemplate增加LoadBanlancerInterceptor拦截器
            维护了一个被@LoadBalanced注解修饰的RestTemplate对象列表，并在这里初始化，通过调用RestTemplateCustomizer的实例来给需要客户端负载均衡的Restmplate增加LoadBanlancerInterceptor拦截器(注：restTemplate是可以扩展自定义拦截器的)
        在拦截后使用getHost()拿到服务名通过Ribbon调用真正的请求。在execute()方法中，第一步通过getServer根据传入的服务名serviceId去获取具体的实例名。(在整合Ribbon时通过RibbonClientConfiguration默认采用了ZoneLandBalancer来实现负载均衡器)。在LoadBalancerRequest的apply(instance)函数,向一个实际的具体服务实例发起请求，其传入的对象继承了HttpRequestWrapper并重写了getURI。在创建请求的时候会调用RibbonLoadBalancerClinet中实现的reconstructURI来组织具体请求的服务实例地址

        SpringClientFactory和RibbonLoadBalancerContext
            SpringClientFactory：该工厂类为每一个不同名的Ribbon客户端生成不同的Spring上下文
            RibbonLoadBalancerContext：该类用于储存被负载均衡使用的API

        负载均衡器
            spring cloud中定义了LoadBalancerClient作为负载均衡器的通用接口，并且针对Ribbon实现了RibbonLoadBalancerClient
            AbstractLoadBalancer
                AbstractLoadBalancer是IloadBalancer接口的抽象实现，其定义了一个关于服务实例的分组枚举类ServerGroup，它包含以下三种不同类型ALL(所有实例)、STATUS_UP(正常服务的实例)、STATUS_NOT_UP(停止服务的实例)。可以根据分组类型获取不同的列表。getLoadBalancerStats对象被用来存储负载均衡各个实例当前的属性和统计信息
            BaseLoadBalancer
                Ribbon负载均衡的基础实现类。
                定义维护两个Server列表。一个用于存储所有，一个用于存储可用
                定义LoadBalancerStats对象
                定义检查实例是否正常的IPing对象
                定义IPingStrategy。默认线性遍历
                定义负载均衡处理规则IRule对象
            DynamicServerListLoadBalancer
                继承BaseLoadBalancer，增加了过滤清单能力
                ServerList，默认使用ribbon与Eureka的整合包内的内容。org.springframework.cloud.netfix.ribbon.eureka下的EurekaRibbonClientConfiguration。通过DiscoberyEnableNIWSServerList中的私有函数obtainServersViaDiscovery通过服务发现获取实例。其内部为通过EurekaClientClient获取注册信息。
                serverListUpdate
                    PollingServerListUpdate:通过定时器更新策略
                    EurekaNotificationServerListUpdate:依赖Eureka事件监听器
                ServerListFilter
                    ZoneAffinityServerListFilter:根据区域过滤。再通过LoadBalancerStats返回符合指标的实例
            ZoneAwareLoadBalancer
                对DynamicServerListLoadBalancer的扩展。在上一个筛选出区域后进行轮询
        负载均衡策略
            AbstractLoadBalancerRule
            RandomRule:随机
            RoundRobinRule:轮询
            WeightdResponseTimeRule:随机的扩展，权重
            。。。。
    4.4配置详解
        自动化配置
    4.5重试机制
        Eureka强调AP,牺牲了一致性
        springCloud整合了Spring retry增加restTemplate的重试能力
 5.服务容错保护Hystrix
    feign是集成了Hystrix的组件
    5.1快速入门
    5.2原理分析
        1.首先构建一个HystrixCommand或是HystrixObservableCommand对象，用来表示对依赖服务的操作请求，同时传递所有需要的参数
            HystrixCommand用在依赖的服务返回单个操作结果的时候
            HystrixObservableCommand用在返回多个操作结果的时候
        2.命令执行
            execute()同步
            queue()异步
            observe()多个结果
            toObserve()多个结果
            其大量使用RxJava(响应式编程),Observable,被观察者。Subscriber订阅者
                Observable可以发出多个事件，每发出一个都会调用对应观察者的onNext()。最后一定是OnError或者onCompleted收尾
            execute是通过queue返回的异步对象的get()实现同步。queue则是通过oObserveable()获得一个Cold Observable
        3.结果是否被缓存
            若当前命令缓存功能是启用的自会立即返回
        4.断路器是否被打开
            当未命中时，如果打开执行第8步(fallback)，未打开则执行第5步
        5.线程池/请求队列/信号量是否占满
            满了则直接fallBack
        6.HystrixObservableCommand.construct()或HystrixCommand.run()
            返回多个或单一结果
        7.计算断路器的健康度
            进行开启关闭断路器
        8.fallback处理
            服务降级，返回统一结果
        9.返回成功的响应
        断路器原理
            HystrixCircuitBreaker
                allowReuest()每个请求都通过他判断是否被执行。使用时不会设置，通过!isOpen()||allowSingleTest()来判断
                    allowSingleTest为半开配置，每5秒允许重试
                isOpen()断路器是否打开
                    QPS未达到阈值返回false
                    错误百分比为达到阈值返回false
                markSuccess()闭合断路器
        依赖隔离
            利用舱壁模式实现线程池隔离避免其相互影响
            使用信号量控制单个服务的并发量
    5.3使用详解
        直接在service层的方法上添加注解
        创建请求
        定义服务降级
        异常处理
        命令名称、分组以及线程池划分
        请求缓存
        请求合并
            虽然整体时间降低，但是会导致单条时间变长
    5.4属性详解
    5.5Hystrix仪表盘
        Hytrix Dashboard监控
    5.6Turbine集群监控
 6.声明式服务调用Feign
    6.1快速入门
        添加springboot启用 feign相关注解
        定义service接口添加注解@FeignClient("XXX"),方法添加注解@RequestMapping
        调用方式为普通的service注入
    6.2参数绑定
        参数绑定与controller使用方式一致
    6.3继承特性
        引入maven包进行继承，但耦合性增加
    6.4Ribbon配置
        全局配置
        指定服务配置
        重试机制
    6.5Hystrix配置
        默认情况下Feign会为将所有的Feign客户端的方法封装到Hystrix
    6.6其他配置
    通过FeignClientsRegistrar生成beanDefinition，被调用时根据jdk动态代理生成具体的RequesTemplate
 7.API网关服务Zuul
    7.1快速入门
        zuul与eureka结合，通过服务发现进行拦截
    7.2路由详解
        可以与hystrix结合控制超时等场景
    7.3过滤器详解
    7.4动态加载
        支持config的动态刷新
 8.分布式配置中心Config
    8.1快速入门
        1.引入依赖
        2.添加相关注解
        3.添加相关配置参数
    8.2服务端详解
        基础架构
            远程git仓库用来持久化
            config Server:git用户名/密码
            本地git仓库:远程git无法连接时使用本地
            ServiceA、ServiceB:具体的微服务应用它们指定了ConfigServer的地址
        客户端应用从配置管理获取配置流程
            1.应用启动时，根据bootstrap.properties中配置的应用名{application}、环境名{profile}、分支名{label}，向Config server请求获取配置信息。
            2.Config Server根据自己维护的git仓库信息和客户端传递过来的配置定位信息去查找配置信息
            3.通过git clone命令将找到的配置信息下载到Config Server的文件系统中
            4.Config Server创建Spring的ApplicationContext实例，并从git本地仓库中加载配置文件，最后将其返回给客户端
            5.客户端应用在获得外部配置文件后加载到客户端的ApplicationConext实例，该配置内容给的优先级高于客户端Jar包内容的优先级，不在加载。
        git仓库配置
            可以根据uri匹配可以配置多个仓库
        高可用配置
            与Eureka联用
    8.3客户端详解
        URI指定配置中心，但以使用高可用为宜
        失败快速响应与重试
        获取远程配置
        动态刷新配置
 9.消息总线Bus
    其支持kafka、RabbitMq、rocketmq、activemq
    强调消息发送
    9.1消息代理
    9.2RabbitMq实现消息总线
    9.3Kafka实现消息总线
    9.4深入理解
 10.消息驱动Stream
    强调发布订阅
    10.1快速入门
    10.2核心概念
    10.3使用详解
    10.4绑定器详解
    10.5配置详解
 11.服务跟踪Sleuth
    即链路追踪
    11.1快速入门
    11.2跟踪原理
    11.3抽样收集
    11.4与LogStash整合
    11.5与Zipkin整合